---
title: Destination Plugins
---

With Jitsu SDK you can implement plugins for Jitsu using Typescript language.

Plugin types:
 * Destination
 * Transformation (Not implemented yet)
 * Source (Not implemented yet)

# Destination Plugin

Jitsu Destination Plugins are designed to work with HTTP based APIs.
Plugin receives Jitsu event and returns object describing HTTP requests necessary to push data to destination.
Jitsu server is in charge of queuing, executing and retrying HTTP requests the same as with builtin destinations like webhook.
Main plugin code doesn't have access to any external resources and doesn't support async execution.

## Create New Destination Plugin

In this article we explain creation of Jitsu destination plugin step by step.
As an example we implement a simple destination that will post message to a Slack webhook 
on receiving Jitsu event with provided types.

## Bootstrapping project

We need to use Jitsu SDK's CLI tool to bootstrap a project for new destination plugin
with some preconfigured configs and placeholder functions:
```shell
npx jitsu-cli extension create --type destination
```

We need to provide project name and directory.
```text
? Please, provide project name: jitsu-slack-destination
? Project directory: /Users/testaccount/projects/jitsu-slack-destination
[info ] - Creating new jitsu project in /Users/testaccount/projects/jitsu-slack-destination
[info ] - Project directory doesn't exist, creating it!
[info ] - âœ¨ Done
```

jitsu-cli will generate project directory structure with set of files typical for Typescript node.js project:
```text
â”œâ”€â”€ package.json
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ destination.ts
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ __test__
â”‚   â””â”€â”€ destination.test.ts
â””â”€â”€ tsconfig.json
```

 * **package.json** â€“ file contains meta information about npm project including name, version
 * **src/index.ts** â€“ file contains the instance of ExtensionDescriptor that Jitsu uses to collect info about destination:
id, icon,  name, description, configuration parameters.
 * **src/destination.ts** â€“ file where must be implemented main logic of destination along with config object and config validator
 * **__test__/destination.test.ts** â€“ test for destination logic must be written here
 * **tsconfig.json** â€“ settings for Typescript compiler. No need to change that

## Destination Config

No destination can work without configuration.
Let's open **src/destination.ts** file and prepare DestinationConfig object for out Slack destination.
Config will consist from webhook url, list of event types to react on and message template for Slack message:

```typescript
export type DestinationConfig = {
  webhookUrl: string, //url of slack webhook https://hooks.slack.com/services/ABC/XYZ/etc
  eventTypes: string, //comma separated list of event types to trigger Slack message
  messageTemplate: string //message template that will be filled with data from event e.g. `New event: ${event_type}!`
}
```

It is nice to tell users in advance in case they make a mistake in config.
That is why destination plugin have ConfigValidator

## Validating Config

Once we have destination config we can implement **validator**.
It is optional part, but it is highly recommended to implement it.

ConfigValidator is the only part of plugin that can access internet using `fetch` method.
The main logic of plugins relies on Jitsu Server pipelines for sending HTTP requests

We replace placeholder implementation with to following code
```typescript
export const validator: ConfigValidator<DestinationConfig> = async (config: DestinationConfig) => {
  //check that all config parameters are present
  if (!config.webhookUrl) {
    return "Missing required parameter: webhookUrl";
  }
  if (!config.eventTypes) {
    return "Missing required parameter: eventTypes";
  }
  if (!config.messageTemplate) {
    return "Missing required parameter: messageTemplate";
  }
  //check validness of provided webhookUrl.
  try {
    //validator must not send any real messages, so we intentionally miss request body
    let response = await fetch(config.webhookUrl, { method: 'post' });
    let responseText = await response.text()
    if (responseText == "invalid_payload") {
      //invalid_payload - is success case because we haven't sent any. It means that webhookUrl is correct
      //otherwise that would be other kind of error response
      return true
    } else {
      return "Error: " + responseText
    }
  } catch (error) {
    return "Error: " + error.toString()
  }
}
```

Now we can test our validator with validate-config action that jitsu-cli already added to the project

```shell
yarn build && yarn validate-config -j '{"webhookUrl":"https://hooks.slack.com/services/ABC/XYZ/etc", "eventTypes":"registration,error", "messageTemplate": "Important event of type: ${event_type}"}'
```

If everything is fine we should get following output:
```text
[info ] - ðŸ¤” Validating configuration {"webhookUrl":"https://hooks.slack.com/services/ABC/XYZ/etc", "eventTypes":"registration,error", "messageTemplate": "Important event of type: ${event_type}"}
[info ] - âœ… Config is valid. Hooray!
[info ] - âœ¨ Done
```

## Pushing to the destination

Lets get to the main part of plugin â€“ pushing data to the target destination.
We need to write proper version of DestinationFunction instead of placeholder:
```typescript
export const destination: DestinationFunction = (event: DefaultJitsuEvent, dstContext: JitsuDestinationContext<DestinationConfig>) => {
  return { url: "https://test.com", method: "POST", body: { a: (event.a || 0) + 1 } };
};
```

DestinationFunction receives two parameters:
 * **event** â€“ type: DefaultJitsuEvent â€“ event received and enriched by Jitsu Server
 * **dstContext** - type: JitsuDestinationContext - destination context containing: **destinationId**, **destinationType**
and what is more important: **config** - config object that we described in the beginning filled by Jitsu Server

**Return values**:

As we mentioned in the beginning, plugin itself doesn't send anything to internet. Instead,
DestinationFunction may return:
 * a single instance of DestinationMessage
 * array of DestinationMessage's - to produce multiple pushes to destination
 * null - null means that Jitsu must skip this event.

DestinationMessage is an object that tells Jitsu Server what HTTP request it needs to make to push data to the destination:
```typescript
export declare type DestinationMessage = {
  url: string;
  method: "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
  headers?: { [key: string]: string };
  body: any;
};
```

### Writing a test

But before actually writing DestinationFunction lets write a test for it.
By writing a test first we will be sure that our DestinationFunction works as we expect.
Otherwise, we risk to create a test that simply matches DestinationFunction results that we just wrote - which may happen to be incorrect.

Let's open **__test__/destination.test.ts**
To write a test we simply need to make a call to the function **testDestination**.
testDestination accepts a single parameter - object of DestinationTestParams type
```typescript
export declare type DestinationTestParams = {
  name: string;                                    //name of the test
  context: JitsuDestinationContext;                //JitsuDestinationContext containing: destinationId, destinationType and config
  destination: DestinationFunction;                //DestinationFunction we are going to test
  event: DefaultJitsuEvent;                        //JitsuEvent
  expectedResult: ObjectSet<DestinationMessage>;   //Result object we expect to get after processing event with provided DestinationFunction
};

```
To implement the test we need to fill DestinationTestParams properties and pass it to the function **testDestination**

```typescript
testDestination({
    name: "proper case",

    context: {
        destinationId: "test",
        destinationType: "slack",
        config: {
            "webhookUrl": "https://hooks.slack.com/services/ABC/XYZ/etc",
            "eventTypes": "registration,error",
            "messageTemplate": "Important event of type: ${event_type}"
        }
    },

    destination: destination,

    event: {
        event_type: 'registration'
    },

    expectedResult: {
        method: "POST",
        url: "https://hooks.slack.com/services/ABC/XYZ/etc",
        body: {
            "blocks": [
                {
                    "type": "section",
                    "text": {
                        "type": "plain_text",
                        "text": "Important event of type: registration"
                    }
                }
            ]
        }
    },
})
```
This is a test for "proper case". We provide testDestination function with:
 * properly set context with a config,
 * Jitsu event - very short one with fields that may be used in plugin code
 * our expectation of HTTP request jitsu should make to a Slack webhook URL in case of receiving such event.

Run the test
```shell
yarn test
```
Test fails because we still need to replace placeholder for DestinationFunction with proper implementation.

In real plugin for production usage one test for "proper case" probably won't be enough.
It would be great to add test cases when event_type is not "registration"
to make sure that nothing bad happens in that cases and we get **null** result.


### Writing DestinationFunction

Now we can write DestinationFunction implementation that prepares DestinationMessage with HTTP request that creates a new Slack Message.
DestinationFunction must skip all events which types diffe.
Let's get back to the **src/destination.ts** file and write some code:

```typescript
function get(obj: any, key: string | string[]) {
    if (typeof key == 'string')
        key = key.split('.');

    if (key.length == 1)
        return obj[key[0]];
    else if (key.length == 0)
        return obj;
    else
        return get(obj[key[0]], key.slice(1));
}

function renderTemplateMessage(str, obj) {
    return str.replace(/\$\{(.+)\}/g, (match, p1) => {
        return get(obj, p1)
    })
}

export const destination: DestinationFunction = (event: DefaultJitsuEvent, dstContext: JitsuDestinationContext<DestinationConfig>) => {
    const eventTypes = dstContext.config.eventTypes.split(",")
    if (!eventTypes.includes(event.event_type)) {
        return null
    }
    let messageText = renderTemplateMessage(dstContext.config.messageTemplate, event)
    if (!messageText) {
        return null;
    }
    //Using Block Kit to build message. See: https://api.slack.com/block-kit
    let blocks = [];
    blocks.push({
        "type": "section",
        "text": {
            "type": "plain_text",
            "text": messageText
        }
    })
    if (event.slack_destinantion_message_blocks) {
        //extensibility with javascript transformation
        blocks.push(...event.slack_destinantion_message_blocks)
    }
    return {
        url: dstContext.config.webhookUrl,
        method: "POST",
        body: {
            "blocks": blocks
        }
    };
};
```

That is it!
Now let's run tests again to make sure that everything works fine.
```shell
yarn test
```
Output must contain following line.
```text
 PASS  __test__/destination.test.ts
  âœ“ proper case (1 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
```

Ok main logic is ready. But nothing appears on Slack yet. We need Jitsu for that.
But before we add our plugin to Jitsu lets fill some meta information that will help users to identify plugin, understand its purpose and properly set config parameters.

## Providing meta information

Let's open file **src/index.ts**
Here we can find placeholder object that jitsu-cli made for us.
Let's fill it with some real data

export type DestinationConfig = {
  webhookUrl: string, //url of slack webhook https://hooks.slack.com/services/ABC/XYZ/etc
  eventTypes: string, //comma separated list of event types to trigger Slack message
  messageTemplate: string //message template that will be filled with data from event e.g. `New event: ${event_type}!`
}
```typescript
const descriptor: ExtensionDescriptor = {
  id: "jitsu-slack-destination",
  displayName: "Slack",
  icon: "<svg enable-background=\"new 0 0 2447.6 2452.5\" viewBox=\"0 0 2447.6 2452.5\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\"><g clip-rule=\"evenodd\" fill-rule=\"evenodd\"><path d=\"m897.4 0c-135.3.1-244.8 109.9-244.7 245.2-.1 135.3 109.5 245.1 244.8 245.2h244.8v-245.1c.1-135.3-109.5-245.1-244.9-245.3.1 0 .1 0 0 0m0 654h-652.6c-135.3.1-244.9 109.9-244.8 245.2-.2 135.3 109.4 245.1 244.7 245.3h652.7c135.3-.1 244.9-109.9 244.8-245.2.1-135.4-109.5-245.2-244.8-245.3z\" fill=\"#36c5f0\"\/><path d=\"m2447.6 899.2c.1-135.3-109.5-245.1-244.8-245.2-135.3.1-244.9 109.9-244.8 245.2v245.3h244.8c135.3-.1 244.9-109.9 244.8-245.3zm-652.7 0v-654c.1-135.2-109.4-245-244.7-245.2-135.3.1-244.9 109.9-244.8 245.2v654c-.2 135.3 109.4 245.1 244.7 245.3 135.3-.1 244.9-109.9 244.8-245.3z\" fill=\"#2eb67d\"\/><path d=\"m1550.1 2452.5c135.3-.1 244.9-109.9 244.8-245.2.1-135.3-109.5-245.1-244.8-245.2h-244.8v245.2c-.1 135.2 109.5 245 244.8 245.2zm0-654.1h652.7c135.3-.1 244.9-109.9 244.8-245.2.2-135.3-109.4-245.1-244.7-245.3h-652.7c-135.3.1-244.9 109.9-244.8 245.2-.1 135.4 109.4 245.2 244.7 245.3z\" fill=\"#ecb22e\"\/><path d=\"m0 1553.2c-.1 135.3 109.5 245.1 244.8 245.2 135.3-.1 244.9-109.9 244.8-245.2v-245.2h-244.8c-135.3.1-244.9 109.9-244.8 245.2zm652.7 0v654c-.2 135.3 109.4 245.1 244.7 245.3 135.3-.1 244.9-109.9 244.8-245.2v-653.9c.2-135.3-109.4-245.1-244.7-245.3-135.4 0-244.9 109.8-244.8 245.1 0 0 0 .1 0 0\" fill=\"#e01e5a\"\/><\/g><\/svg>",
  description: "Destination that posts messages to Slack Webhook on receiving Jitsu evens with specified event_types",
  configurationParameters: [
    {
      id: "webhookUrl",
      type: "string",
      required: true,
      displayName: "Webhook URL",
      documentation: "Url of slack webhook https://hooks.slack.com/services/ABC/XYZ/etc"
    },
    {
      id: "eventTypes",
      type: "string",
      required: true,
      displayName: "Event Types",
      documentation: "comma separated list of event types to trigger Slack message"
    }
    {
      id: "messageTemplate",
      type: "string",
      required: true,
      displayName: "Message Template",
      documentation: "Template of Slack message.<br/>You can use ${parameter} expressions to add values from incoming event, e.g.:<br/>Welcome ${user.id}<br/>Received event ${event_type}"
    }
  ],
};
```

if you want Jitsu to display nice graphic icon along with destination name you need to provide svg code of icon to "icon" parameter of ExtensionDescriptor.

## Adding to Jitsu

To add our plugin to jitsu we need to build it and make package.

To build plugin code use:
```shell
yarn build
```
For making package there are 2 options:

#### handmade .tgz tarball

Making .tgz is fast and simple.
This way is perfect if we don't plan to share our plugin with anybody else.

Use command like that to make compressed .tgz package of destination project directory:
```shell
tar -cvzf package_name.tgz -C /workspace_directory/ destination_project_directory
```
In case of our destination command will look like:
```shell
tar -cvzf jitsu-slack-destination.tgz -C /Users/testaccount/projects/ jitsu-slack-destination
```

`jitsu-slack-destination.tgz` file will appear in current directory.

#### publish to npm repository

In case we want to share plugin with other people - publishing to public npm repository is a preferable way.
You need to have account in https://www.npmjs.com

The following commands in project directory may be used to publish package to npmjs repository.
```shell
npm login
```
```shell
npm publish
```
npm will ask to provide some additional details to complete publishing

### Setting up Jitsu Server

Users of standalone jitsu server can setup destination based on plugin since version 1.38.
Simply add new destination of type **npm**, information about plugin package and config to `eventnative.yaml` config file:
```yaml
destinations:
...
  my_slack_destination:
    only_tokens:
      - my_token
    type: npm
    package: /home/eventnative/data/plugins/jitsu-slack-destination.tgz
    mode: stream
    config:
      webhookUrl: "https://hooks.slack.com/services/ABC/XYZ/etc"
      eventTypes: "registration,error"
      messageTemplate: "Important event of type: ${event_type}"
```

**package** can be:
 * **filesystem path** - in case of docker image, provided path need to be reachable inside of docker image filesystem.
/home/eventnative/data/plugins/ needs to be mounted to host filesystem directory where file jitsu-slack-destination.tgz is located,
e.g. following param may be added to docker run command: `-v /Users/testaccount/projects/:/home/eventnative/data/plugins/`
 * **HTTP URL** - e.g.: `https://my-site.com/plugins/jitsu-slack-destination.tgz`
 * **npm package name** - in case plugin is published to npm repository. It is recommended to provide package name with version expression,
to prevent backward compatibility issues when new version of plugin will require some features that current version of server doesn't support,
e.g.: `jitsu-slack-destination@^1.0.0`

### Setting up Jitsu Joint Image or Configurator UI

UI support for adding plugin based destinations is not ready yet.
To make your destination plugin appear in Jitsu Configurator UI please create a new ticket or pull request in
[jitsu repository](https://github.com/jitsucom/jitsu)
