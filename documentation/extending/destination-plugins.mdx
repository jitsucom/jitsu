---
title: Destination Plugins
---

With Jitsu SDK you can implement plugins for Jitsu using Typescript language.

Plugin types:
 * Destination
 * Transformation (Not implemented yet)
 * Source (Not implemented yet)

# Destination Plugin

Jitsu Destination Plugins are designed to work with HTTP based APIs.
Plugin receives Jitsu event and returns object describing HTTP requests necessary to push data to destination.
Jitsu server is in charge of queuing, executing and retrying HTTP requests the same as with builtin destinations like webhook.
Main plugin code doesn't have access to any external resources and doesn't support async execution.

## Create New Destination Plugin

In this article we explain creation of Jitsu destination plugin step by step.
As an example we implement a simple destination that will post a tweet welcoming new user on receiving Jitsu event with event_type = "registration".

## Bootstrapping project

We need to use Jitsu SDK's CLI tool to bootstrap a project for new destination plugin
with some preconfigured configs and placeholder functions:
```shell
npx jitsu-cli extension create --type destination
```

We need to provide project name and directory.
```text
? Please, provide project name: jitsu-twitter-destination
? Project directory: /Users/testaccount/projects/jitsu-twitter-destination
[info ] - Creating new jitsu project in /Users/testaccount/projects/jitsu-twitter-destination
[info ] - Project directory doesn't exist, creating it!
[info ] - âœ¨ Done
```

jitsu-cli will generate project directory structure with set of files typical for Typescript node.js project:
```text
â”œâ”€â”€ package.json
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ destination.ts
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ __test__
â”‚   â””â”€â”€ destination.test.ts
â””â”€â”€ tsconfig.json
```

 * **package.json** â€“ file contains meta information about npm project including name, version
 * **src/index.ts** â€“ file contains the instance of ExtensionDescriptor that Jitsu uses to collect info about destination:
id, icon,  name, description, configuration parameters.
 * **src/destination.ts** â€“ file where must be implemented main logic of destination along with config object and config validator
 * **__test__/destination.test.ts** â€“ test for destination logic must be written here
 * **tsconfig.json** â€“ settings for Typescript compiler. No need to change that

## Destination Config

No destination can work without configuration.
Let's open **src/destination.ts** file and prepare DestinationConfig object for out Twitter destination.
Config will consist from oauth 2.0 access token and text template for tweets:

```typescript
export type DestinationConfig = {
  accessToken: string, //oauth 2.0 access token
  tweetTemplate: string //string literals template e.g. `Welcome new user ${event.user?.id} !ðŸŽ‰`
}
```

Destination plugin must not handle authorization process. If our twitter plugin manage to become part of Jitsu server -
Jitsu server will handle authorization and obtain accessToken. For UI users that will look like "Grant Jitsu Access to Twitter" button.

What plugin can do â€“ is to check validness of access token.

## Validating Config

Once we have destination config we can implement **validator**.
It is optional part, but it is highly recommended to implement it.

We replace placeholder implementation with to following code
```typescript
export const validator: ConfigValidator<DestinationConfig> = async (config: DestinationConfig) => {
  //check that all config parameters are present
  if (!config.tweetTemplate) {
    return "Missing required parameter: tweetTemplate";
  }
  if (!config.accessToken) {
    return "Missing required parameter: accessToken";
  }
  //check that authorization passed
  return await fetch("https://api.twitter.com/2/users/me", {
    method: 'get',
    headers: {
      "Authorization": "Bearer " + config.accessToken
    }
  }).then(response => response.json())
      .then(result => {
        if (result.data) {
          //we got data in response
          return true
        } else {
          return "Error: " + result["status"] + ": " +  result["title"] + " (" + result["detail"] + ")"
        }
      })
      .catch(error => {
        return "Error: " + error.toString()
      });
}
```

Now we can test our validator with validate-config action that jitsu-cli already added to the project

```shell
yarn build && yarn validate-config -j '{"tweetTemplate":"Welcome new user ${event.user?.id} !ðŸŽ‰", "accessToken":"Q0Mzb0VhZ0"}'
```

If everything is fine we should get following output:
```text
[info ] - ðŸ¤” Validating configuration {"tweetTemplate":"sasd","accessToken":"Q0Mzb0VhZ0"}
[info ] - âœ… Config is valid. Hooray!
[info ] - âœ¨ Done
```

## Pushing to the destination

Lets get to the main part of plugin â€“ pushing data to the target destination.
We need to replace placeholder of DestinationFunction with the proper version:
```typescript
export const destination: DestinationFunction = (event: DefaultJitsuEvent, dstContext: JitsuDestinationContext<DestinationConfig>) => {
  return { url: "https://test.com", method: "POST", body: { a: (event.a || 0) + 1 } };
};
```

DestinationFunction receives two parameters:
 * **event** â€“ type: DefaultJitsuEvent â€“ event received and enriched by Jitsu Server
 * **dstContext** - type: JitsuDestinationContext - destination context containing: **destinationId**, **destinationType**
and what is more important: **config** - config object that we described in the beginning filled by Jitsu Server

Return values:
As we mentioned in the beginning, plugin itself don't send anything to internet. Instead,
DestinationFunction may return: a single instance of DestinationMessage, array of DestinationMessage's or null.
When DestinationFunction return null it means that Jitsu must skip this event.

DestinationMessage is an object that tells Jitsu Server what HTTP request it needs to make to push data to the destination.
```typescript
export declare type DestinationMessage = {
  url: string;
  method: "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
  headers?: { [key: string]: string };
  body: any;
};
```

### Writing a test

But before actually writing DestinationFunction lets write a test for it.
By writing a test first we will be sure that our DestinationFunction works as we expect.
Otherwise, we risk to create a test that simply matches DestinationFunction results that we just wrote - which may happen to be incorrect.

Let's open **__test__/destination.test.ts**
To write a test we simply need to make a call to the function **testDestination**.
testDestination accepts a single parameter - object of DestinationTestParams type
```typescript
export declare type DestinationTestParams = {
  name: string;                                    //name of the test
  context: JitsuDestinationContext;                //JitsuDestinationContext containing: destinationId, destinationType and config
  destination: DestinationFunction;                //DestinationFunction we are going to test
  event: DefaultJitsuEvent;                        //JitsuEvent
  expectedResult: ObjectSet<DestinationMessage>;   //Result object we expect to get after processing event with provided DestinationFunction
};

```
To implement the test we need to fill DestinationTestParams properties and pass it to the function **testDestination**

```typescript
testDestination({
  name: "proper case",
  context: {
    destinationId: "test",
    destinationType: "twitter",
    config: {
      "tweetTemplate":"Welcome new user ${event.user?.id}!ðŸŽ‰",
      "accessToken":"Q0Mzb0VhZ0"
    }
  },
  destination: destination,
  event: {
    event_type: 'registration',
    user: {
      id: "test_new_user",
      email: "test_new_user@example.com"
    }
  },
  expectedResult: {
    method: "POST",
    url: "https://api.twitter.com/2/tweets",
    headers: {
      "Authorization": "Bearer Q0Mzb0VhZ0",
      "Content-type": "application/json",
    },
    body: {"text": "Welcome new user test_new_user!ðŸŽ‰"},
  },
})
```
This is a test for "proper case". We provide testDestination function with:
 * properly set context with a config,
 * Jitsu event - very short one with fields that may be used in plugin code
 * our expectation of HTTP request jitsu should make to Twitter API in case of receiving such event.

Run the test
```shell
yarn test
```
Test fails because we still need to replace placeholder for DestinationFunction with proper implementation.

In real plugin for production usage one test for "proper case" probably won't be enough.
It would be great to add test cases when event_type is not "registration"
to make sure that nothing bad happens in that cases and we get **null** result.


### Writing DestinationFunction

Now we can write DestinationFunction implementation that prepares DestinationMessage with HTTP request that creates a new tweet.
DestinationFunction must skip all events with event type other than "registration".
Let's get back to the **src/destination.ts** file and write some code:

```typescript
export const destination: DestinationFunction = (event: DefaultJitsuEvent, dstContext: JitsuDestinationContext<DestinationConfig>) => {
  if (event.event_type != "registration") {
    return null
  }
  let tweetText = eval("`" + dstContext.config.tweetTemplate + "`")
  if (!tweetText) {
    return null;
  }
  return {
    url: "https://api.twitter.com/2/tweets",
    method: "POST",
    headers: {
      "Authorization": "Bearer " + dstContext.config.accessToken,
      "Content-type": "application/json",
    },
    body: {
      "text": tweetText
    }
  };
};
```

That is it!
Now let's run tests again to make sure that everything works fine.
```shell
yarn test
```
Output must contain following line.
```text
 PASS  __test__/destination.test.ts
  âœ“ proper case (1 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
```

Ok main logic is ready. But nothing appears on Twitter yet. We need Jitsu for that.
But before we add our plugin to Jitsu lets fill some meta information that will help users identify plugin, understand its purpose and properly set config parameters.

## Providing meta information

Let's open file **src/index.ts**
Here we can find placeholder object that jitsu-cli made for us.
Let's fill it with some real data

```typescript
const descriptor: ExtensionDescriptor = {
  id: "jitsu-twitter-destination",
  displayName: "Twitter",
  icon: "<svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" xml:space=\"preserve\" width=\"70.5556mm\" height=\"57.3391mm\" version=\"1.1\" style=\"shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd\"\r\nviewBox=\"0 0 6701 5446\"\r\n xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\">\r\n <defs>\r\n  <style type=\"text\/css\">\r\n   <![CDATA[\r\n    .fil0 {fill:#41ABE1}\r\n   ]]>\r\n  <\/style>\r\n <\/defs>\r\n <g id=\"Livello_x0020_1\">\r\n  <metadata id=\"CorelCorpID_0Corel-Layer\"\/>\r\n  <path class=\"fil0\" d=\"M6701 645c-247,109 -512,183 -790,216 284,-170 502,-440 604,-761 -266,158 -560,272 -873,334 -251,-267 -608,-434 -1004,-434 -759,0 -1375,616 -1375,1375 0,108 12,213 36,313 -1143,-57 -2156,-605 -2834,-1437 -118,203 -186,439 -186,691 0,477 243,898 612,1144 -225,-7 -437,-69 -623,-172 0,6 0,11 0,17 0,666 474,1222 1103,1348 -115,31 -237,48 -362,48 -89,0 -175,-9 -259,-25 175,546 683,944 1284,955 -471,369 -1063,589 -1708,589 -111,0 -220,-7 -328,-19 608,390 1331,618 2108,618 2529,0 3912,-2095 3912,-3912 0,-60 -1,-119 -4,-178 269,-194 502,-436 686,-712z\"\/>\r\n <\/g>\r\n<\/svg>",
  description: "Destination that posts a tweet welcoming new user on receiving \"registration\" event.",
  configurationParameters: [
    {
      id: "accessToken",
      type: "string",
      required: true,
      displayName: "Access Token",
      documentation: "Oauth 2.0 Access Token"
    },
    {
      id: "tweetTemplate",
      type: "string",
      required: true,
      displayName: "Tweet template",
      documentation: "Template of tweet text.<br/>You can use string literals expressions to add values from incoming event, e.g.:<br/>Welcome ${event.user?.id}<br/>Received event ${event.event_type}"
    }
  ],
};
```

if you want Jitsu to display nice graphic icon along with destination name you need to provide svg code of icon to "icon" parameter of ExtensionDescriptor.

## Adding to Jitsu

To add our plugin to jitsu we need to build it and make package.

To build plugin code use:
```shell
yarn build
```
For making package there are 2 options:

#### handmade .tgz tarball

Making .tgz is fast and simple.
This way is perfect if we don't plan to share our plugin with anybody else.

Use command like that to make compressed .tgz package of destination project directory:
```shell
tar -cvzf package_name.tgz -C /workspace_directory/ destination_project_directory
```
In case of our destination command will look like:
```shell
tar -cvzf jitsu-twitter-destination.tgz -C /Users/testaccount/projects/ jitsu-twitter-destination
```

**jitsu-twitter-destination.tgz** file will appear in current directory.

#### publish to npm repository

In case we want to share plugin with other people - publishing to public npm repository is a preferable way.
You need to have account in https://www.npmjs.com

The following commands in project directory may be used to publish package to npmjs repository.
```shell
npm login
```
```shell
npm publish
```
npm will ask to provide some additional details to complete publishing

### Setting up Jitsu Server

Users of standalone jitsu server can setup destination based on plugin since version 1.38.
Simply add new destination of type **npm**, information about plugin package and config to `eventnative.yaml` config file:
```yaml
destinations:
...
  my_twitter_destination:
    only_tokens:
      - my_token
    type: npm
    package: /home/eventnative/data/plugins/jitsu-twitter-destination.tgz
    mode: stream
    config:
      accessToken: "Q0Mzb0VhZ0"
      tweetTemplate: "Welcome new user ${event.user?.id} !\U0001F389"
```

**package** can be:
 * **filesystem path** - in case of docker image, provided path need to be reachable inside of docker image filesystem.
/home/eventnative/data/plugins/ needs to be mounted to host filesystem directory where file jitsu-twitter-destination.tgz is located,
e.g.: `-v /Users/testaccount/projects/:/home/eventnative/data/plugins/`
 * **HTTP URL** - e.g.: `https://my-site.com/plugins/jitsu-twitter-destination.tgz`
 * **npm package name** - in case plugin is published to npm repository. It is recommended to provide package name with version expression,
to prevent backward compatibility issues when new version of plugin will require some features that current version of server doesn't support,
e.g.: `jitsu-twitter-destination@^1.0.0`

### Setting up Jitsu Joint Image or Configurator UI

UI support for adding plugin based destinations is not ready yet.
To make your destination plugin appear in Jitsu Configurator UI please create a new ticket or pull request in
[jitsu repository](https://github.com/jitsucom/jitsu)
