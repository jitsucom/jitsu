import GithubProvider from "next-auth/providers/github";
import GoogleProvider from "next-auth/providers/google";
import CredentialsProvider from "next-auth/providers/credentials";
import { NextAuthOptions, User } from "next-auth";
import { db } from "./server/db";
import { checkHash, requireDefined } from "juava";
import { ApiError } from "./shared/errors";
import { getServerLog } from "./server/log";
import { withProductAnalytics } from "./server/telemetry";
import { NextApiRequest } from "next";

const crypto = require("crypto");

const log = getServerLog("auth");

const googleProvider = GoogleProvider({
  clientId: "942257799287-a7jjl052dugnfav58ij8lihq17o9mc41.apps.googleusercontent.com",
  clientSecret: "1eEfuTzfp5f9ZkDHg4YqnqhE",
});
const githubProvider = GithubProvider({
  clientId: process.env.GITHUB_CLIENT_ID as string,
  clientSecret: process.env.GITHUB_CLIENT_SECRET as string,
});

const firebase = {
  apiKey: "AIzaSyDBm2HqvxleuJyD9xo8rh0vo1TQGp8Vohg",
  authDomain: "backbase.jitsu.com",
  databaseURL: "https://tracker-285220.firebaseio.com",
  projectId: "tracker-285220",
  storageBucket: "tracker-285220.appspot.com",
  messagingSenderId: "942257799287",
  appId: "1:942257799287:web:e3b0bd3435f929d6a00672",
  measurementId: "G-6ZMG0NSJP8",
};

const credentialsProvider =
  process.env.TEST_CREDENTIALS &&
  CredentialsProvider({
    authorize(credentials) {
      if (!process.env.TEST_CREDENTIALS || !credentials) {
        return null;
      }
      log.atInfo().log(JSON.stringify(credentials));
      const userRecord = process.env.TEST_CREDENTIALS.split(",")
        .map(s => s.trim().split(":"))
        .find(([user]) => user.toLowerCase() === credentials.username.toLowerCase());
      if (!userRecord) {
        log.atWarn().log(`Failed attempt to login with ${credentials.username}: no such user`);
        return null;
      }
      if (!checkHash(userRecord[1], credentials.password)) {
        log.atWarn().log(`Failed attempt to login with ${credentials.username}: invalid password`);
        return null;
      }
      const userId = "id-" + credentials.username.toLowerCase().replace("@", "-").replace(".", "-");
      return {
        id: userId,
        externalId: userId,
        email: credentials.username.toLowerCase(),
        name: credentials.username.toLowerCase(),
      };
    },
    credentials: {
      username: { label: "Email", type: "text" },
      password: { label: "Password", type: "password" },
    },
  });

export async function getOrCreateUser(opts: {
  externalId: string;
  loginProvider: string;
  name?: string;
  email: string;
  // we only need this for product analytics, so it's optional
  req?: NextApiRequest;
}): Promise<User> {
  const { externalId, loginProvider, email, name = email } = opts;
  let user = await db.prisma().userProfile.findFirst({ where: { externalId, loginProvider } });
  if (!user) {
    if (process.env.DISABLE_SIGNUP === "true" || process.env.DISABLE_SIGNUP === "1") {
      throw new ApiError("Sign up is disabled", { code: "signup-disabled" });
    }
    //first user is admin
    const admin = !(await db.prisma().userProfile.count());
    user = await db.prisma().userProfile.create({
      data: {
        email,
        name,
        externalId: externalId,
        loginProvider: loginProvider,
        admin,
      },
    });
    await withProductAnalytics(p => p.track("user_created"), {
      user: { email, name, internalId: user.id, externalId, loginProvider },
      req: opts.req,
    });
  } else if (user.name !== name || user.email !== email) {
    await db.prisma().userProfile.update({ where: { id: user.id }, data: { name, email } });
  }
  return user;
}

function generateSecret(base: (string | undefined)[]) {
  const hash = crypto.createHash("sha256");
  hash.update(base.map(s => s || "empty").join(":"));
  const secretKey = hash.digest("hex");
  log.atInfo().log("Using autogenerated JWT key", secretKey);
  return secretKey;
}

export const nextAuthConfig: NextAuthOptions = {
  // Configure one or more authentication providers
  providers: [githubProvider, googleProvider, credentialsProvider].filter(provider => !!provider) as any,
  pages: {
    error: "/error/auth", // Error code passed in query string as ?error=
  },

  secret:
    process.env.JWT_SECRET ||
    generateSecret([
      process.env.GITHUB_CLIENT_ID,
      process.env.GOOGLE_CLIENT_ID,
      process.env.DATABASE_URL,
      process.env.REDIS_URL,
    ]),
  callbacks: {
    jwt: async props => {
      const loginProvider = (props.account?.provider || props.token.loginProvider || "credentials") as string;
      const externalId = requireDefined(props.token.sub, `JWT token .sub is not defined`);
      const email = requireDefined(props.token.email, `JWT token .email is not defined`);
      const user = await getOrCreateUser({
        externalId,
        loginProvider,
        email,
        name: props.token.name || email,
      });
      return {
        internalId: user.id,
        externalId: externalId,
        externalUsername: props.profile?.["login"],
        loginProvider: loginProvider,
        ...props.token,
      };
    },
    async session({ session, token }) {
      return {
        ...session,
        internalId: token.internalId,
        loginProvider: token.loginProvider,
        externalId: token.externalId,
        externalUsername: token.externalUsername,
      };
    },
  },
};
