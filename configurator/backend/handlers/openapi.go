package handlers

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/jitsucom/jitsu/configurator/authorization"
	"github.com/jitsucom/jitsu/configurator/destinations"
	"github.com/jitsucom/jitsu/configurator/emails"
	"github.com/jitsucom/jitsu/configurator/entities"
	"github.com/jitsucom/jitsu/configurator/jitsu"
	"github.com/jitsucom/jitsu/configurator/middleware"
	"github.com/jitsucom/jitsu/configurator/openapi"
	"github.com/jitsucom/jitsu/configurator/random"
	"github.com/jitsucom/jitsu/configurator/ssl"
	"github.com/jitsucom/jitsu/configurator/storages"
	jadapters "github.com/jitsucom/jitsu/server/adapters"
	"github.com/jitsucom/jitsu/server/airbyte"
	jauth "github.com/jitsucom/jitsu/server/authorization"
	"github.com/jitsucom/jitsu/server/config"
	jdestinations "github.com/jitsucom/jitsu/server/destinations"
	jdrivers "github.com/jitsucom/jitsu/server/drivers"
	jdriversairbyte "github.com/jitsucom/jitsu/server/drivers/airbyte"
	jdriversbase "github.com/jitsucom/jitsu/server/drivers/base"
	jdriverssinger "github.com/jitsucom/jitsu/server/drivers/singer"
	jgeo "github.com/jitsucom/jitsu/server/geo"
	"github.com/jitsucom/jitsu/server/jsonutils"
	"github.com/jitsucom/jitsu/server/logging"
	jmiddleware "github.com/jitsucom/jitsu/server/middleware"
	"github.com/jitsucom/jitsu/server/notifications"
	"github.com/jitsucom/jitsu/server/safego"
	jsources "github.com/jitsucom/jitsu/server/sources"
	jstorages "github.com/jitsucom/jitsu/server/storages"
	jsystem "github.com/jitsucom/jitsu/server/system"
	"github.com/jitsucom/jitsu/server/telemetry"
	"github.com/jitsucom/jitsu/server/timestamp"
	"github.com/mitchellh/mapstructure"
	"gopkg.in/yaml.v3"
)

const (
	telemetryUsageKey            = "usage"
	APIKeysGettingErrMsg         = "API keys getting error"
	DestinationsGettingErrMsg    = "Destinations getting error"
	SourcesGettingErrMsg         = "Sources getting error"
	ProjectSettingsGettingErrMsg = "Project settings getting error"
	ErrMalformedData             = "System error: malformed data"
	commonUIDFieldName           = "_uid"
	configHeaderText             = `Generated by https://cloud.jitsu.com
Documentation: https://jitsu.com/docs

If executed out of our docker container and batch destinations are used, set up events logging
log:
  path: <path to event logs directory>
`
	jsonContentType = "application/json"
)

//stubS3Config is used in generate Jitsu Server yaml config
var stubS3Config = &jadapters.S3Config{
	AccessKeyID: "Please fill this field with your S3 credentials",
	SecretKey:   "Please fill this field with your S3 credentials",
	Bucket:      "Please fill this field with your S3 bucket",
	Region:      "Please fill this field with your S3 region",
}

type Server struct {
	Name *yaml.Node `json:"name" yaml:"name,omitempty"`
}

type Config struct {
	Server       Server                                `json:"server" yaml:"server,omitempty"`
	APIKeys      []*entities.APIKey                    `json:"api_keys" yaml:"api_keys,omitempty"`
	Destinations map[string]*config.DestinationConfig  `json:"destinations" yaml:"destinations,omitempty"`
	Sources      map[string]*jdriversbase.SourceConfig `json:"sources" yaml:"sources,omitempty"`
}

type SystemConfiguration struct {
	SMTP        bool
	SelfHosted  bool
	DockerHUBID string
	Tag         string
	BuiltAt     string
}

//OpenAPI is an openapi.ServerInterface implementation wrapper
type OpenAPI struct {
	authService           *authorization.Service
	emailService          *emails.Service
	configurationsService *storages.ConfigurationsService
	systemConfiguration   *SystemConfiguration
	jitsuService          *jitsu.Service
	updateExecutor        *ssl.UpdateExecutor
	defaultS3             *jadapters.S3Config
}

func NewOpenAPI(authService *authorization.Service, emailService *emails.Service, configurationsService *storages.ConfigurationsService,
	systemConfiguration *SystemConfiguration, jitsuService *jitsu.Service, updateExecutor *ssl.UpdateExecutor, defaultS3 *jadapters.S3Config) *OpenAPI {
	return &OpenAPI{
		authService:           authService,
		emailService:          emailService,
		configurationsService: configurationsService,
		systemConfiguration:   systemConfiguration,
		jitsuService:          jitsuService,
		updateExecutor:        updateExecutor,
		defaultS3:             defaultS3,
	}
}

func (oa *OpenAPI) GetApiKeysConfiguration(c *gin.Context) {
	//check if middleware has aborted the request
	if c.IsAborted() {
		return
	}

	begin := timestamp.Now()
	keys, err := oa.configurationsService.GetAllAPIKeys()
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(APIKeysGettingErrMsg, err))
		return
	}

	var tokens []jauth.Token
	for _, k := range keys {
		tokens = append(tokens, jauth.Token{
			ID:           k.ID,
			ClientSecret: k.ClientSecret,
			ServerSecret: k.ServerSecret,
			Origins:      k.Origins,
		})
	}

	resp := &jauth.TokensPayload{Tokens: tokens}
	b, _ := json.Marshal(resp)

	anyObject, err := convertToObject(b)
	if err != nil {
		logging.Errorf("System error: malformed data %s: %v", string(b), err)
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse(ErrMalformedData, nil))
		return
	}

	logging.Debugf("APIKeys response in [%.2f] seconds", timestamp.Now().Sub(begin).Seconds())
	c.JSON(http.StatusOK, anyObject)
}

func (oa *OpenAPI) GenerateDefaultProjectApiKey(c *gin.Context) {
	//check if middleware has aborted the request
	if c.IsAborted() {
		return
	}

	req := &openapi.ProjectIdRequest{}
	if err := c.BindJSON(req); err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid input JSON", err))
		return
	}

	if req.ProjectID == "" {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid input data", errors.New("projectID is required field")))
		return
	}

	if !hasAccessToProject(c, req.ProjectID) {
		c.AbortWithStatusJSON(http.StatusForbidden, middleware.ForbiddenProject(req.ProjectID))
		return
	}

	if err := oa.configurationsService.CreateDefaultAPIKey(req.ProjectID); err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Failed to create default key for project", err))
		return
	}

	c.JSON(http.StatusOK, OpenAPIOKResponse())
}

func (oa *OpenAPI) BecomeAnotherCloudUser(c *gin.Context, params openapi.BecomeAnotherCloudUserParams) {
	//check if middleware has aborted the request
	if c.IsAborted() {
		return
	}

	pem, err := extractPermissions(c)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(err.Error(), nil))
		return
	}

	if !pem.IsAdmin() {
		//check user email via authService.IsAdmin()
		userID := c.GetString(middleware.UserIDKey)
		isAdmin, err := oa.authService.IsAdmin(userID)
		if err != nil {
			c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(err.Error(), nil))
			return
		}

		if !isAdmin {
			c.AbortWithStatusJSON(http.StatusForbidden, ErrorResponse("Only admins can use this API method", nil))
			return
		}
	}

	userToken, err := oa.authService.GenerateUserToken(params.UserId)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(err.Error(), nil))
		return
	}

	c.JSON(http.StatusOK, openapi.TokenResponse{Token: userToken})
}

func (oa *OpenAPI) CreateFreeTierPostgresDatabase(c *gin.Context) {
	//check if middleware has aborted the request
	if c.IsAborted() {
		return
	}

	req := &openapi.ProjectIdRequest{}
	if err := c.BindJSON(req); err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid input JSON", err))
		return
	}

	if req.ProjectID == "" {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid input data", errors.New("projectID is required field")))
		return
	}

	if !hasAccessToProject(c, req.ProjectID) {
		c.AbortWithStatusJSON(http.StatusForbidden, middleware.ForbiddenProject(req.ProjectID))
		return
	}

	database, err := oa.configurationsService.CreateDefaultDestination(req.ProjectID)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Failed to create a free tier database", err))
		return
	}

	b, _ := json.Marshal(database)
	anyObject, err := convertToObject(b)
	if err != nil {
		logging.Errorf("System error: malformed data %s: %v", string(b), err)
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse(ErrMalformedData, nil))
		return
	}

	c.JSON(http.StatusOK, anyObject)
}

func (oa *OpenAPI) GetDestinationsConfiguration(c *gin.Context) {
	//check if middleware has aborted the request
	if c.IsAborted() {
		return
	}

	begin := timestamp.Now()
	destinationsMap, err := oa.configurationsService.GetAllDestinations()
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(DestinationsGettingErrMsg, err))
		return
	}

	geoResolvers, err := oa.configurationsService.GetGeoDataResolvers()
	if err != nil {
		logging.SystemErrorf("Error getting geo resolvers: %v", err)
		geoResolvers = map[string]*entities.GeoDataResolver{}
	}

	apiKeysPerProjectByID, err := oa.configurationsService.GetAllAPIKeysPerProjectByID()
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(APIKeysGettingErrMsg, err))
		return
	}

	idConfig := map[string]config.DestinationConfig{}
	for projectID, destinationsEntity := range destinationsMap {
		if len(destinationsEntity.Destinations) == 0 {
			continue
		}
		postHandleDestinationIds := make([]string, 0)
		for _, d := range destinationsEntity.Destinations {
			if d.Type == jstorages.DbtCloudType {
				postHandleDestinationIds = append(postHandleDestinationIds, projectID+"."+d.UID)
			}
		}
		for _, destination := range destinationsEntity.Destinations {
			destinationID := projectID + "." + destination.UID
			enDestinationConfig, err := destinations.MapConfig(destinationID, destination, oa.defaultS3, postHandleDestinationIds)
			if err != nil {
				logging.Errorf("Error mapping destination config for destination type: %s id: %s projectID: %s err: %v", destination.Type, destination.UID, projectID, err)
				continue
			}

			//connect with geo resolver
			geoResolverConfig, ok := geoResolvers[projectID]
			if ok && geoResolverConfig.MaxMind != nil && geoResolverConfig.MaxMind.Enabled {
				enDestinationConfig.GeoDataResolverID = projectID
			}

			//check api keys existence
			projectsApikeysByID, ok := apiKeysPerProjectByID[projectID]
			projectApiKeysInOnlyTokens := []string{}
			if ok {
				//filter api keys that don't belong to the project
				for _, apiKeyID := range enDestinationConfig.OnlyTokens {
					if _, ok := projectsApikeysByID[apiKeyID]; ok {
						projectApiKeysInOnlyTokens = append(projectApiKeysInOnlyTokens, apiKeyID)
					}
				}
			}

			enDestinationConfig.OnlyTokens = projectApiKeysInOnlyTokens
			idConfig[destinationID] = *enDestinationConfig
		}
	}

	resp := &jdestinations.Payload{Destinations: idConfig}
	b, _ := json.Marshal(resp)

	anyObject, err := convertToObject(b)
	if err != nil {
		logging.Errorf("System error: malformed data %s: %v", string(b), err)
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse(ErrMalformedData, nil))
		return
	}

	logging.Debugf("Destinations response in [%.2f] seconds", timestamp.Now().Sub(begin).Seconds())
	c.JSON(http.StatusOK, anyObject)
}

func (oa *OpenAPI) EvaluateDestinationJSTransformationScript(c *gin.Context) {
	//check if middleware has aborted the request
	if c.IsAborted() {
		return
	}

	req := &openapi.AnyObject{}
	err := c.BindJSON(req)
	if err != nil {
		bodyExtractionErrorMessage := fmt.Sprintf("Failed to get objects body from request: %v", err)
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(bodyExtractionErrorMessage, nil))
		return
	}

	field, ok := req.Get("field")
	if ok && fmt.Sprint(field) == "_transform" {
		destinationEntity := &entities.Destination{}

		rawConfig, ok := req.Get("config")
		if !ok {
			c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid input data", errors.New("config is required field when field = _transform")))
			return
		}
		if err := jsonutils.UnmarshalConfig(rawConfig, destinationEntity); err != nil {
			c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Failed to unmarshal destination config", nil))
			return
		}

		enDestinationConfig, err := destinations.MapConfig("evaluate", destinationEntity, oa.defaultS3, nil)
		if err != nil {
			c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(fmt.Sprintf("Failed to map [%s] config to Jitsu format", destinationEntity.Type), err))
			return
		}

		enDestinationConfigMap := map[string]interface{}{}
		if err = mapstructure.Decode(enDestinationConfig, &enDestinationConfigMap); err != nil {
			c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(fmt.Sprintf("Failed to map [%s] enDestinationConfigMap to map", destinationEntity.Type), err))
			return
		}
		req.Set("config", enDestinationConfigMap)
	}

	requestBytes, err := req.MarshalJSON()
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Failed to marshal request body to json", err))
		return
	}

	code, content, err := oa.jitsuService.EvaluateExpression(requestBytes)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Failed to get response from Jitsu server", err))
		return
	}

	c.Data(code, jsonContentType, content)
}

func (oa *OpenAPI) TestDestinationConfiguration(c *gin.Context) {
	//check if middleware has aborted the request
	if c.IsAborted() {
		return
	}

	req := &openapi.AnyObject{}
	err := c.BindJSON(req)
	if err != nil {
		bodyExtractionErrorMessage := fmt.Sprintf("Failed to get objects body from request: %v", err)
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(bodyExtractionErrorMessage, nil))
		return
	}

	destinationEntity := &entities.Destination{}
	if err := jsonutils.UnmarshalConfig(req, destinationEntity); err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Failed to unmarshal destination config", nil))
		return
	}

	enDestinationConfig, err := destinations.MapConfig("test_connection", destinationEntity, oa.defaultS3, nil)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(fmt.Sprintf("Failed to map [%s] config to Jitsu Server format", destinationEntity.Type), err))
		return
	}

	b, err := json.Marshal(enDestinationConfig)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Failed to serialize destination config", err))
		return
	}

	code, content, err := oa.jitsuService.TestDestination(b)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Failed to get response from jitsu server", err))
		return
	}

	if code == http.StatusOK {
		c.JSON(http.StatusOK, &openapi.StatusResponse{Status: "Connection established"})
		return
	}

	c.Data(code, jsonContentType, content)
}

func (oa *OpenAPI) GetGeoDataResolvers(c *gin.Context) {
	//check if middleware has aborted the request
	if c.IsAborted() {
		return
	}

	begin := timestamp.Now()
	geoDataResolversMap, err := oa.configurationsService.GetGeoDataResolvers()
	if err != nil {
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse(DestinationsGettingErrMsg, err))
		return
	}

	idConfig := map[string]*jgeo.ResolverConfig{}
	for projectID, geoDataResolverConfig := range geoDataResolversMap {
		if geoDataResolverConfig.MaxMind != nil && geoDataResolverConfig.MaxMind.Enabled {
			maxmindURL := geoDataResolverConfig.MaxMind.LicenseKey
			if !strings.HasPrefix(maxmindURL, jgeo.MaxmindPrefix) {
				maxmindURL = jgeo.MaxmindPrefix + maxmindURL
			}
			idConfig[projectID] = &jgeo.ResolverConfig{
				Type:   jgeo.MaxmindType,
				Config: jgeo.MaxMindConfig{MaxMindURL: maxmindURL},
			}
		}
	}

	resp := &jgeo.Payload{GeoResolvers: idConfig}
	b, _ := json.Marshal(resp)

	anyObject, err := convertToObject(b)
	if err != nil {
		logging.Errorf("System error: malformed data %s: %v", string(b), err)
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse(ErrMalformedData, nil))
		return
	}

	logging.Debugf("Geo data resolvers response in [%.2f] seconds", timestamp.Now().Sub(begin).Seconds())
	c.JSON(http.StatusOK, anyObject)
}

func (oa *OpenAPI) GenerateJitsuServerYamlConfiguration(c *gin.Context, params openapi.GenerateJitsuServerYamlConfigurationParams) {
	//check if middleware has aborted the request
	if c.IsAborted() {
		return
	}

	projectID := string(params.ProjectId)
	if !hasAccessToProject(c, projectID) {
		c.AbortWithStatusJSON(http.StatusForbidden, middleware.ForbiddenProject(projectID))
		return
	}

	//** API keys (auth) **
	keys, err := oa.configurationsService.GetAPIKeysByProjectID(projectID)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(APIKeysGettingErrMsg, err))
		return
	}

	// ** Destinations **
	projectDestinations, err := oa.configurationsService.GetDestinationsByProjectID(projectID)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(DestinationsGettingErrMsg, err))
		return
	}
	postHandleDestinationIds := make([]string, 0)
	for _, d := range projectDestinations {
		if d.Type == jstorages.DbtCloudType {
			postHandleDestinationIds = append(postHandleDestinationIds, d.UID)
		}
	}
	mappedDestinations := make(map[string]*config.DestinationConfig)
	for _, destination := range projectDestinations {
		//dots can't be serialized in yaml configuration
		//destinationID := projectID + "." + destination.UID
		destinationID := destination.UID
		destinationConfig, err := destinations.MapConfig(destinationID, destination, stubS3Config, postHandleDestinationIds)

		if err != nil {
			c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Failed to build destinations response", err))
			return
		}
		mappedDestinations[destinationID] = destinationConfig
	}

	// ** Sources **
	projectSources, err := oa.configurationsService.GetSourcesByProjectID(projectID)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(SourcesGettingErrMsg, err))
		return
	}

	projectSettings, err := oa.configurationsService.GetProjectSettings(projectID)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(ProjectSettingsGettingErrMsg, err))
		return
	}

	mappedSources := make(map[string]*jdriversbase.SourceConfig)
	for _, source := range projectSources {
		//dots can't be serialized in yaml configuration
		//sourceID := projectID + "." + source.SourceID
		sourceID := source.SourceID

		var destinationIDs []string
		for _, destinationID := range source.Destinations {
			//dots can't be serialized in yaml configuration
			//destinationIDs = append(destinationIDs, projectID+"."+destinationID)
			destinationIDs = append(destinationIDs, destinationID)
		}
		mappedConfig, err := mapSourceConfig(source, destinationIDs, postHandleDestinationIds, projectSettings)
		if err != nil {
			c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(fmt.Sprintf("Failed to map source [%s] config", sourceID), err))
			return
		}
		mappedSources[sourceID] = &mappedConfig
	}

	// building yaml response
	server := Server{Name: &yaml.Node{Kind: yaml.ScalarNode, Value: random.String(5), LineComment: "rename server if another name is desired"}}
	serverConfig := Config{Server: server, APIKeys: keys, Destinations: mappedDestinations, Sources: mappedSources}

	marshal, err := yaml.Marshal(&serverConfig)
	configYaml := yaml.Node{}

	if err = yaml.Unmarshal(marshal, &configYaml); err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Failed to deserialize result configuration", err))
		return
	}
	configYaml.HeadComment = configHeaderText

	c.Header("Content-Type", "application/yaml")
	encoder := yaml.NewEncoder(c.Writer)
	defer encoder.Close()

	encoder.SetIndent(2)
	err = encoder.Encode(&configYaml)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Failed write response", err))
	}
}

func (oa *OpenAPI) SendCustomPayloadNotificationAsynchronously(c *gin.Context) {
	//check if middleware has aborted the request
	if c.IsAborted() {
		return
	}

	req := &openapi.AnyObject{}
	err := c.BindJSON(req)
	if err != nil {
		bodyExtractionErrorMessage := fmt.Sprintf("Failed to get objects body from request: %v", err)
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(bodyExtractionErrorMessage, nil))
		return
	}

	b, _ := json.MarshalIndent(req, "", "\t")

	notifications.Custom(string(b))

	c.JSON(http.StatusOK, OpenAPIOKResponse())
}

func (oa *OpenAPI) GetSourcesConfiguration(c *gin.Context) {
	//check if middleware has aborted the request
	if c.IsAborted() {
		return
	}

	begin := timestamp.Now()

	sourcesMap, err := oa.configurationsService.GetAllSources()
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(SourcesGettingErrMsg, err))
		return
	}

	idConfig := map[string]jdriversbase.SourceConfig{}
	for projectID, sourcesEntity := range sourcesMap {
		if len(sourcesEntity.Sources) == 0 {
			continue
		}
		dests, err := oa.configurationsService.GetDestinationsByProjectID(projectID)
		if err != nil {
			c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(SourcesGettingErrMsg, err))
			return
		}
		postHandleDestinationIds := make([]string, 0)
		for _, d := range dests {
			if d.Type == jstorages.DbtCloudType {
				postHandleDestinationIds = append(postHandleDestinationIds, projectID+"."+d.UID)
			}
		}
		projectSettings, err := oa.configurationsService.GetProjectSettings(projectID)
		if err != nil {
			c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(ProjectSettingsGettingErrMsg, err))
			return
		}
		for _, source := range sourcesEntity.Sources {
			sourceID := projectID + "." + source.SourceID

			var destinationIDs []string
			for _, destinationID := range source.Destinations {
				destinationIDs = append(destinationIDs, projectID+"."+destinationID)
			}
			mappedSourceConfig, err := mapSourceConfig(source, destinationIDs, postHandleDestinationIds, projectSettings)
			if err != nil {
				c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(fmt.Sprintf("Failed to map source [%s] config", sourceID), err))
				return
			}

			idConfig[sourceID] = mappedSourceConfig
		}
	}

	resp := &jsources.Payload{Sources: idConfig}
	b, _ := json.Marshal(resp)

	anyObject, err := convertToObject(b)
	if err != nil {
		logging.Errorf("System error: malformed data %s: %v", string(b), err)
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse(ErrMalformedData, nil))
		return
	}

	logging.Debugf("Sources response in [%.2f] seconds", timestamp.Now().Sub(begin).Seconds())
	c.JSON(http.StatusOK, anyObject)
}

func (oa *OpenAPI) TestSourceConfiguration(c *gin.Context) {
	//check if middleware has aborted the request
	if c.IsAborted() {
		return
	}

	req := &openapi.AnyObject{}
	err := c.BindJSON(req)
	if err != nil {
		bodyExtractionErrorMessage := fmt.Sprintf("Failed to get objects body from request: %v", err)
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(bodyExtractionErrorMessage, nil))
		return
	}

	sourceEntity := &entities.Source{}
	if err := jsonutils.UnmarshalConfig(req, sourceEntity); err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Failed to unmarshal source config", nil))
		return
	}

	enSourceConfig, err := mapSourceConfig(sourceEntity, []string{}, []string{}, openapi.ProjectSettings{})
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(fmt.Sprintf("Failed to map [%s] config to Jitsu Server format", sourceEntity.SourceType), err))
		return
	}

	b, err := json.Marshal(enSourceConfig)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Failed to serialize source config", err))
		return
	}

	code, content, err := oa.jitsuService.TestSource(b)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Failed to get response from Jitsu server", err))
		return
	}

	if code == http.StatusOK {
		c.JSON(http.StatusOK, &openapi.StatusResponse{Status: "Connection established"})
		return
	}

	c.Data(code, jsonContentType, content)
}

func (oa *OpenAPI) ReissueProjectSSLCertificates(c *gin.Context, params openapi.ReissueProjectSSLCertificatesParams) {
	//check if middleware has aborted the request
	if c.IsAborted() {
		return
	}

	projectID := string(params.ProjectId)
	if !hasAccessToProject(c, projectID) {
		c.AbortWithStatusJSON(http.StatusForbidden, middleware.ForbiddenProject(projectID))
		return
	}

	if oa.updateExecutor == nil {
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse("ssl isn't configured in Jitsu configuration", nil))
		return
	}

	if params.Async != nil && *params.Async {
		safego.Run(func() {
			if err := oa.updateExecutor.RunForProject(projectID); err != nil {
				logging.Errorf("Error updating SSL for project [%s]: %v", projectID, err)
			}
		})

		c.JSON(http.StatusOK, &openapi.StatusResponse{Status: "scheduled SSL update"})
		return
	}

	if err := oa.updateExecutor.RunForProject(projectID); err != nil {
		logging.Errorf("Error updating SSL for project [%s]: %v", projectID, err)
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(fmt.Sprintf("Error running SSL update for project [%s]", projectID), err))
		return
	}

	c.JSON(http.StatusOK, OpenAPIOKResponse())
}

func (oa *OpenAPI) ReissueAllConfiguredSSLCertificates(c *gin.Context, params openapi.ReissueAllConfiguredSSLCertificatesParams) {
	//check if middleware has aborted the request
	if c.IsAborted() {
		return
	}

	if oa.updateExecutor == nil {
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse("ssl isn't configured in Jitsu configuration", nil))
		return
	}

	if params.Async != nil && *params.Async {
		safego.Run(func() {
			if err := oa.updateExecutor.Run(); err != nil {
				logging.Errorf("Error updating all SSL: %v", err)
			}
		})

		c.JSON(http.StatusOK, &openapi.StatusResponse{Status: "scheduled SSL update"})
		return
	}

	if err := oa.updateExecutor.Run(); err != nil {
		logging.Errorf("Error updating all SSL: %v", err)
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Error running SSL update", err))
		return
	}

	c.JSON(http.StatusOK, OpenAPIOKResponse())
}

func (oa *OpenAPI) GetSystemConfiguration(c *gin.Context) {
	if c.IsAborted() {
		return
	}

	exist, err := oa.authService.UsersExist()
	if err != nil {
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse("Error checking users existence", err))
		return
	}

	telemetryConfig, err := oa.configurationsService.GetParsedTelemetry()
	if err != nil && err != storages.ErrConfigurationNotFound {
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse("Error getting telemetry configuration", err))
		return
	}

	var telemetryUsageDisabled bool
	if telemetryConfig != nil && telemetryConfig.Disabled != nil {
		usageDisabled, ok := telemetryConfig.Disabled[telemetryUsageKey]
		if ok {
			telemetryUsageDisabled = usageDisabled
		}
	}

	currentConfiguration := jsystem.Configuration{
		Authorization:               oa.authService.GetAuthorizationType(),
		Users:                       exist,
		SMTP:                        oa.systemConfiguration.SMTP,
		SelfHosted:                  oa.systemConfiguration.SelfHosted,
		SupportWidget:               !oa.systemConfiguration.SelfHosted,
		DefaultS3Bucket:             !oa.systemConfiguration.SelfHosted,
		SupportTrackingDomains:      !oa.systemConfiguration.SelfHosted,
		TelemetryUsageDisabled:      telemetryUsageDisabled,
		ShowBecomeUser:              !oa.systemConfiguration.SelfHosted,
		DockerHubID:                 oa.systemConfiguration.DockerHUBID,
		OnlyAdminCanChangeUserEmail: oa.systemConfiguration.SelfHosted,
		Tag:                         oa.systemConfiguration.Tag,
		BuiltAt:                     oa.systemConfiguration.BuiltAt,
	}

	data, _ := json.Marshal(currentConfiguration)
	object, err := convertToObject(data)
	if err != nil {
		logging.Errorf("System error: malformed data %s: %v", string(data), err)
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse(ErrMalformedData, nil))
		return
	}

	c.JSON(http.StatusOK, object)
}

func (oa *OpenAPI) GetSystemVersion(c *gin.Context) {
	if c.IsAborted() {
		return
	}

	version := openapi.VersionObject{Version: oa.systemConfiguration.Tag, BuiltAt: oa.systemConfiguration.BuiltAt}

	c.JSON(http.StatusOK, version)
}

func (oa *OpenAPI) GetTelemetrySettings(c *gin.Context) {
	//check if middleware has aborted the request
	if c.IsAborted() {
		return
	}

	configBytes, err := oa.configurationsService.GetTelemetry()
	if err != nil {
		if err == storages.ErrConfigurationNotFound {
			configBytes, _ = json.Marshal(map[string]interface{}{})
		} else {
			c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Error getting telemetry configuration", err))
			return
		}
	}

	anyObject, err := convertToObject(configBytes)
	if err != nil {
		logging.Errorf("System error: malformed data %s: %v", string(configBytes), err)
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse(ErrMalformedData, nil))
		return
	}

	c.JSON(http.StatusOK, anyObject)
}

func (oa *OpenAPI) UserEmailChange(c *gin.Context) {
	//check if middleware has aborted the request
	if c.IsAborted() {
		return
	}

	req := &openapi.UserEmailChangeJSONBody{}
	if err := c.BindJSON(req); err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid input JSON", err))
		return
	}

	if req.OldEmail == "" {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid input data", errors.New("old_email is required field")))
		return
	}

	if req.NewEmail == "" {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid input data", errors.New("new_email is required field")))
		return
	}

	err := oa.authService.ChangeEmail(req.OldEmail, req.NewEmail)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(fmt.Sprintf("Failed to change user email from %s to %s", req.OldEmail, req.NewEmail), err))
		return
	}

	c.JSON(http.StatusOK, OpenAPIOKResponse())
}

func (oa *OpenAPI) GetUserInfo(c *gin.Context) {
	if c.IsAborted() {
		return
	}

	userID := c.GetString(middleware.UserIDKey)

	data, err := oa.configurationsService.GetConfigWithLock(authorization.UsersInfoCollection, userID)
	if err != nil {
		if err == storages.ErrConfigurationNotFound {
			data, _ = json.Marshal(make(map[string]interface{}))
		} else {
			c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(err.Error(), nil))
			return
		}
	}

	object, err := convertToObject(data)
	if err != nil {
		logging.Errorf("System error: malformed data %s: %v", string(data), err)
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse(ErrMalformedData, nil))
		return
	}

	c.JSON(http.StatusOK, object)
}

func (oa *OpenAPI) UpdateUserInfo(c *gin.Context) {
	if c.IsAborted() {
		return
	}

	userID := c.GetString(middleware.UserIDKey)

	req := &openapi.AnyObject{}
	err := c.BindJSON(req)
	if err != nil {
		bodyExtractionErrorMessage := fmt.Sprintf("Failed to get user info body from request: %v", err)
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(bodyExtractionErrorMessage, nil))
		return
	}

	savedData, err := oa.configurationsService.SaveConfigWithLock(authorization.UsersInfoCollection, userID, req)
	if err != nil {
		configStoreErrorMessage := fmt.Sprintf("Failed to save user info [%s]: %v", userID, err)
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(configStoreErrorMessage, nil))
		return
	}

	anyObject, err := convertToObject(savedData)
	if err != nil {
		logging.Errorf("System error: malformed data %s: %v", string(savedData), err)
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse(ErrMalformedData, nil))
		return
	}

	c.JSON(http.StatusOK, anyObject)
}

func (oa *OpenAPI) UserSignUp(c *gin.Context) {
	if c.IsAborted() {
		return
	}

	req := &openapi.UserSignUpJSONRequestBody{}
	if err := c.BindJSON(req); err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid input JSON", err))
		return
	}

	if req.Email == "" {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid input data", errors.New("email is required field")))
		return
	}

	if req.Password == "" {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid input data", errors.New("password is required field")))
		return
	}

	if req.Name == "" {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid input data", errors.New("name is required field")))
		return
	}

	if req.Company == "" {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid input data", errors.New("company is required field")))
		return
	}

	td, err := oa.authService.SignUp(req.Email, req.Password)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(err.Error(), nil))
		return
	}

	//store telemetry settings
	err = oa.configurationsService.SaveTelemetry(map[string]bool{telemetryUsageKey: req.UsageOptout})
	if err != nil {
		logging.Errorf("Error saving telemetry configuration [%v] to storage: %v", req.UsageOptout, err)
	}

	//telemetry user
	user := &telemetry.UserData{
		Company:     req.Company,
		EmailOptout: req.EmailOptout,
		UsageOptout: req.UsageOptout,
	}
	if !req.EmailOptout {
		user.Email = req.Email
		user.Name = req.Name
	}
	telemetry.User(user)

	c.JSON(http.StatusOK, openapi.TokensResponse{
		AccessToken:  td.AccessTokenEntity.AccessToken,
		RefreshToken: td.RefreshTokenEntity.RefreshToken,
		UserId:       td.AccessTokenEntity.UserID,
	})
}

func (oa *OpenAPI) UserPasswordChange(c *gin.Context) {
	if c.IsAborted() {
		return
	}

	req := &openapi.UserPasswordChangeJSONRequestBody{}
	if err := c.BindJSON(req); err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid input JSON", err))
		return
	}

	if req.NewPassword == nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid input data", errors.New("new_password is required field")))
		return
	}

	//Extract token from all places including deprecated ones
	token, ok := middleware.ExtractBearerToken(c)
	if !ok {
		token = middleware.ExtractTokenFromDeprecatedParameters(c)
	}

	td, err := oa.authService.ChangePassword(req.ResetId, token, *req.NewPassword)
	if err != nil {
		if err == authorization.ErrResetIDNotFound {
			c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("The link has been expired!", nil))
			return
		}

		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(err.Error(), nil))
		return
	}

	c.JSON(http.StatusOK, openapi.TokensResponse{
		AccessToken:  td.AccessTokenEntity.AccessToken,
		RefreshToken: td.RefreshTokenEntity.RefreshToken,
		UserId:       td.AccessTokenEntity.UserID,
	})
}

func (oa *OpenAPI) UserPasswordReset(c *gin.Context) {
	if c.IsAborted() {
		return
	}

	if !oa.emailService.IsConfigured() {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("SMTP isn't configured", nil))
		return
	}

	req := &openapi.UserPasswordResetJSONRequestBody{}
	if err := c.BindJSON(req); err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid input JSON", err))
		return
	}

	if req.Email == "" {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("email is required", nil))
		return
	}

	if req.Callback == nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("callback is required", nil))
		return
	}

	resetID, email, err := oa.authService.CreateResetID(req.Email)
	if err != nil {
		if err == authorization.ErrUserNotFound {
			c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(err.Error(), nil))
			return
		}

		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse(err.Error(), nil))
		return
	}

	err = oa.emailService.SendResetPassword(email, strings.ReplaceAll(*req.Callback, "{{token}}", resetID))
	if err != nil {
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse("Error sending email message", err))
		return
	}

	c.JSON(http.StatusOK, OpenAPIOKResponse())
}

func (oa *OpenAPI) UserSignIn(c *gin.Context) {
	if c.IsAborted() {
		return
	}

	req := &openapi.UserSignInJSONRequestBody{}
	if err := c.BindJSON(req); err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid input JSON", err))
		return
	}

	if req.Email == "" {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid input data", errors.New("email is required body parameter")))
		return
	}

	if req.Password == "" {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid input data", errors.New("password is required body parameter")))
		return
	}

	td, err := oa.authService.SignIn(req.Email, req.Password)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusUnauthorized, ErrorResponse(err.Error(), nil))
		return
	}

	c.JSON(http.StatusOK, openapi.TokensResponse{
		AccessToken:  td.AccessTokenEntity.AccessToken,
		RefreshToken: td.RefreshTokenEntity.RefreshToken,
		UserId:       td.AccessTokenEntity.UserID,
	})
}

func (oa *OpenAPI) UserSignOut(c *gin.Context) {
	if c.IsAborted() {
		return
	}

	token := c.GetString(middleware.TokenKey)

	err := oa.authService.SignOut(token)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(err.Error(), nil))
		return
	}

	c.JSON(http.StatusOK, OpenAPIOKResponse())
}

func (oa *OpenAPI) UserAuthorizationTokenRefresh(c *gin.Context) {
	if c.IsAborted() {
		return
	}

	req := &openapi.UserAuthorizationTokenRefreshJSONRequestBody{}
	if err := c.BindJSON(req); err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid input JSON", err))
		return
	}

	if req.RefreshToken == "" {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse("Invalid data JSON", errors.New("refresh_token is required field")))
		return
	}

	td, err := oa.authService.Refresh(req.RefreshToken)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusUnauthorized, ErrorResponse(err.Error(), nil))
		return
	}

	c.JSON(http.StatusOK, openapi.TokensResponse{
		AccessToken:  td.AccessTokenEntity.AccessToken,
		RefreshToken: td.RefreshTokenEntity.RefreshToken,
		UserId:       td.AccessTokenEntity.UserID,
	})
}

func (oa *OpenAPI) GetObjectsByProjectIdAndObjectType(c *gin.Context, projectIDI openapi.ProjectId, objectTypeI openapi.ObjectType) {
	if c.IsAborted() {
		return
	}

	projectID := string(projectIDI)
	objectType := string(objectTypeI)

	if !hasAccessToProject(c, projectID) {
		c.AbortWithStatusJSON(http.StatusForbidden, middleware.ForbiddenProject(projectID))
		return
	}

	objects, err := oa.configurationsService.GetConfigWithLock(objectType, projectID)
	if err != nil {
		if err == storages.ErrConfigurationNotFound {
			objects, _ = json.Marshal(make(map[string]interface{}))
		}
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(fmt.Sprintf("failed to get objects for object type=[%s], projectID=[%s]: %v", objectType, projectID, err), nil))
		return
	}

	result, err := convertToObjectsArray(objects, objectType)
	if err != nil {
		logging.Errorf("System error: malformed data %s: %v", string(objects), err)
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse(ErrMalformedData, nil))
		return
	}

	c.JSON(http.StatusOK, result)
}

func (oa *OpenAPI) CreateObjectInProject(c *gin.Context, projectIDI openapi.ProjectId, objectTypeI openapi.ObjectType) {
	if c.IsAborted() {
		return
	}

	projectID := string(projectIDI)
	objectType := string(objectTypeI)

	if !hasAccessToProject(c, projectID) {
		c.AbortWithStatusJSON(http.StatusForbidden, middleware.ForbiddenProject(projectID))
		return
	}

	req := &openapi.AnyObject{}
	err := c.BindJSON(req)
	if err != nil {
		bodyExtractionErrorMessage := fmt.Sprintf("Failed to get objects body from request: %v", err)
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(bodyExtractionErrorMessage, nil))
		return
	}

	b, err := oa.configurationsService.SaveConfigWithLock(objectType, projectID, req)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(fmt.Sprintf("failed to save objects [%s], id=[%s]: %v", objectType, projectID, err), nil))
		return
	}

	newObject, err := convertToObject(b)
	if err != nil {
		logging.Errorf("System error: malformed data %s: %v", string(b), err)
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse(ErrMalformedData, nil))
		return
	}

	c.JSON(http.StatusOK, newObject)
}

func (oa *OpenAPI) DeleteObjectByUid(c *gin.Context, projectIDI openapi.ProjectId, objectTypeI openapi.ObjectType, objectUIDI openapi.ObjectUid) {
	if c.IsAborted() {
		return
	}

	projectID := string(projectIDI)
	objectType := string(objectTypeI)
	objectUID := string(objectUIDI)

	if !hasAccessToProject(c, projectID) {
		c.AbortWithStatusJSON(http.StatusForbidden, middleware.ForbiddenProject(projectID))
		return
	}

	objectArrayPath := getObjectArrayPathByObjectType(objectType)
	objectMeta := &storages.ObjectMeta{
		IDFieldPath: commonUIDFieldName,
		Value:       objectUID,
	}

	deletedObject, err := oa.configurationsService.DeleteObjectWithLock(objectType, projectID, objectArrayPath, objectMeta)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(fmt.Sprintf("failed to delete object [%s] in project [%s], id=[%s]: %v", objectType, projectID, objectUID, err), nil))
		return
	}

	result, err := convertToObject(deletedObject)
	if err != nil {
		logging.Errorf("System error: malformed data %s: %v", string(deletedObject), err)
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse(ErrMalformedData, nil))
		return
	}

	c.JSON(http.StatusOK, result)
}

func (oa *OpenAPI) GetObjectByUid(c *gin.Context, projectIDI openapi.ProjectId, objectTypeI openapi.ObjectType, objectUIDI openapi.ObjectUid) {
	if c.IsAborted() {
		return
	}

	projectID := string(projectIDI)
	objectType := string(objectTypeI)
	objectUID := string(objectUIDI)

	if !hasAccessToProject(c, projectID) {
		c.AbortWithStatusJSON(http.StatusForbidden, middleware.ForbiddenProject(projectID))
		return
	}

	objectArrayPath := getObjectArrayPathByObjectType(objectType)
	objectMeta := &storages.ObjectMeta{
		IDFieldPath: commonUIDFieldName,
		Value:       objectUID,
	}

	object, err := oa.configurationsService.GetObjectWithLock(objectType, projectID, objectArrayPath, objectMeta)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(fmt.Sprintf("failed to get object [%s] in project [%s], id=[%s]: %v", objectType, projectID, objectUID, err), nil))
		return
	}

	result, err := convertToObject(object)
	if err != nil {
		logging.Errorf("System error: malformed data %s: %v", string(object), err)
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse(ErrMalformedData, nil))
		return
	}

	c.JSON(http.StatusOK, result)
}

func (oa *OpenAPI) UpdateObjectByUid(c *gin.Context, projectIDI openapi.ProjectId, objectTypeI openapi.ObjectType, objectUIDI openapi.ObjectUid) {
	if c.IsAborted() {
		return
	}

	projectID := string(projectIDI)
	objectType := string(objectTypeI)
	objectUID := string(objectUIDI)

	if !hasAccessToProject(c, projectID) {
		c.AbortWithStatusJSON(http.StatusForbidden, middleware.ForbiddenProject(projectID))
		return
	}

	req := &openapi.AnyObject{}
	err := c.BindJSON(req)
	if err != nil {
		bodyExtractionErrorMessage := fmt.Sprintf("Failed to get patch objects body from request: %v", err)
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(bodyExtractionErrorMessage, nil))
		return
	}

	patchPayload := &storages.PatchPayload{
		ObjectArrayPath: getObjectArrayPathByObjectType(objectType),
		ObjectMeta: &storages.ObjectMeta{
			IDFieldPath: commonUIDFieldName,
			Value:       objectUID,
		},
		//extract
		Patch: req.AdditionalProperties,
	}

	newObject, err := oa.configurationsService.PatchConfigWithLock(objectType, projectID, patchPayload)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(fmt.Sprintf("failed to patch object [%s] in project [%s], id=[%s]: %v", objectType, projectID, objectUID, err), nil))
		return
	}

	result, err := convertToObject(newObject)
	if err != nil {
		logging.Errorf("System error: malformed data %s: %v", string(newObject), err)
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse(ErrMalformedData, nil))
		return
	}

	c.JSON(http.StatusOK, result)
}

func (oa *OpenAPI) GetUsersProjects(c *gin.Context) {
	if c.IsAborted() {
		return
	}

	projects, err := oa.authService.GetUserProjects(c.GetString(middleware.UserIDKey))
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(fmt.Sprintf("failed to get user's projects: %v", err), nil))
		return
	}

	result := openapi.AnyArray{}
	for _, project := range projects {
		data, _ := json.Marshal(project)
		object, err := convertToObject(data)
		if err != nil {
			logging.Errorf("System error: malformed data %s: %v", string(data), err)
			c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse(ErrMalformedData, nil))
			return
		}

		result = append(result, *object)
	}

	c.JSON(http.StatusOK, result)
}

func (oa *OpenAPI) GetProjectSettings(c *gin.Context, projectIDI openapi.ProjectId) {
	if c.IsAborted() {
		return
	}

	projectID := string(projectIDI)

	if !hasAccessToProject(c, projectID) {
		c.AbortWithStatusJSON(http.StatusForbidden, middleware.ForbiddenProject(projectID))
		return
	}

	result, err := oa.configurationsService.GetProjectSettings(projectID)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorResponse(fmt.Sprintf("failed to get project settings: %v", err), nil))
		return
	}

	c.JSON(http.StatusOK, result)
}

func (oa *OpenAPI) PatchProjectSettings(c *gin.Context, projectIDI openapi.ProjectId) {
	if c.IsAborted() {
		return
	}

	projectID := string(projectIDI)
	if !hasAccessToProject(c, projectID) {
		c.AbortWithStatusJSON(http.StatusForbidden, middleware.ForbiddenProject(projectID))
		return
	}

	req := &openapi.AnyObject{}
	err := c.BindJSON(req)
	if err != nil {
		bodyExtractionErrorMessage := fmt.Sprintf("Failed to get patch objects body from request: %v", err)
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(bodyExtractionErrorMessage, nil))
		return
	}

	result, err := oa.configurationsService.PatchProjectSettings(projectID, req.AdditionalProperties)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorResponse(fmt.Sprintf("failed to patch settings in project [%s]: %v", projectID, err), nil))
		return
	}

	c.JSON(http.StatusOK, result)
}

func hasAccessToProject(c *gin.Context, projectID string) bool {
	permissions, ok := c.Get(middleware.Permissions)
	if !ok {
		logging.SystemErrorf("unable to find resolved permissions in context: %s", c.Request.URL.String())
		return false
	}

	pa, ok := permissions.(*middleware.ProjectAccess)
	if !ok {
		logging.SystemErrorf("failed to cast object %v of type %T to *middleware.ProjectAccess: %s", permissions, permissions, c.Request.URL.String())
		return false
	}

	return pa.HasAccess(projectID)
}

func extractPermissions(c *gin.Context) (*middleware.ProjectAccess, error) {
	permissions, ok := c.Get(middleware.Permissions)
	if !ok {
		logging.SystemErrorf("unable to find resolved permissions in context: %s", c.Request.URL.String())
		return nil, errors.New("permissions don't exist")
	}

	pa, ok := permissions.(*middleware.ProjectAccess)
	if !ok {
		logging.SystemErrorf("failed to cast object %v of type %T to *middleware.ProjectAccess: %s", permissions, permissions, c.Request.URL.String())
		return nil, errors.New("wrong permissions type")
	}

	return pa, nil
}

//OpenAPIOKResponse returns openapi ok response wrapper
func OpenAPIOKResponse() *openapi.StatusResponse {
	return &openapi.StatusResponse{Status: jmiddleware.StatusOK}
}

//ErrorResponse returns openapi error response wrapper
func ErrorResponse(message string, err error) *openapi.ErrorObject {
	eo := &openapi.ErrorObject{
		Message: message,
	}
	if err != nil {
		errMsg := err.Error()
		eo.Error = &errMsg
	}

	return eo
}

func convertToObjectsArray(objects []byte, objectType string) (*openapi.AnyArray, error) {
	anyObjectWithResult, err := convertToObject(objects)
	if err != nil {
		return nil, err
	}

	var arrayOfObjects []interface{}
	arrayPath := getObjectArrayPathByObjectType(objectType)
	result := openapi.AnyArray{}

	//check if payload has structure: { key: []} or just {}
	if arrayPath != "" {
		arrayOfObjectsI, ok := anyObjectWithResult.Get(arrayPath)
		if !ok {
			return nil, fmt.Errorf("objects [%s] doesn't have path [%s] in array", objectType, arrayPath)
		}

		arrayOfObjects, ok = arrayOfObjectsI.([]interface{})
		if !ok {
			return nil, fmt.Errorf("objects [%s] path [%s] must be an array", objectType, arrayPath)
		}

		for _, object := range arrayOfObjects {
			anyObject := openapi.AnyObject{}
			b, _ := json.Marshal(object)
			if err := (&anyObject).UnmarshalJSON(b); err != nil {
				return nil, fmt.Errorf("error serializing object in array: %v", err)
			}

			result = append(result, anyObject)
		}

	} else {
		anyObject := openapi.AnyObject{}
		if err := (&anyObject).UnmarshalJSON(objects); err != nil {
			return nil, fmt.Errorf("error serializing object in array: %v", err)
		}

		result = append(result, anyObject)
	}

	return &result, nil
}

func convertToObject(b []byte) (*openapi.AnyObject, error) {
	anyObject := openapi.AnyObject{}
	if err := anyObject.UnmarshalJSON(b); err != nil {
		return nil, fmt.Errorf("error serializing response: %v", err)
	}

	return &anyObject, nil
}

//paths some entities arrays can be different from entity type
func getObjectArrayPathByObjectType(objectType string) string {
	switch objectType {
	case "api_keys":
		return "keys"
	case "geo_data_resolvers":
		return ""
	default:
		return objectType
	}
}

//mapSourceConfig mapped configurator source into server format
//puts table names if not set
func mapSourceConfig(source *entities.Source, sourceDestinationIDs []string, postHandleDestinations []string, projectSettings openapi.ProjectSettings) (jdriversbase.SourceConfig, error) {
	var notificationConfig map[string]interface{}
	if projectSettings.Notifications != nil {
		notificationConfig = map[string]interface{}{
			"slack": projectSettings.Notifications.Slack,
		}
	}

	enSource := jdriversbase.SourceConfig{
		SourceID:               source.SourceID,
		Type:                   source.SourceType,
		Destinations:           sourceDestinationIDs,
		PostHandleDestinations: postHandleDestinations,
		Collections:            source.Collections,
		Config:                 source.Config,
		Schedule:               source.Schedule,
		Notifications:          notificationConfig,
	}

	if source.SourceType == jdriversbase.SingerType {
		if err := enrichWithSingerTableNamesMapping(&enSource); err != nil {
			return jdriversbase.SourceConfig{}, err
		}
	} else if source.SourceType == jdriversbase.AirbyteType {
		if err := enrichWithAirbyteTableNamesMapping(&enSource); err != nil {
			return jdriversbase.SourceConfig{}, err
		}
	} else {
		//process collections if not Singer
		collections, err := jdrivers.ParseCollections(&enSource)
		if err != nil {
			return jdriversbase.SourceConfig{}, err
		}

		//enrich with table names = source (without project + collection name)
		for _, col := range collections {
			if col.TableName == "" {
				col.TableName = source.SourceID + "_" + col.Name
			}
		}

		var collectionsInterface []interface{}
		for _, col := range collections {
			collectionsInterface = append(collectionsInterface, col)
		}
		enSource.Collections = collectionsInterface
	}

	return enSource, nil
}

//enrichWithSingerTableNamesMapping enriches with table names = source (without project + singer stream)
// - gets stream names from JSON
// - puts it with sourceID prefix into mapping map
func enrichWithSingerTableNamesMapping(enSource *jdriversbase.SourceConfig) error {
	config := &jdriverssinger.Config{}
	if err := jsonutils.UnmarshalConfig(enSource.Config, config); err != nil {
		return err
	}

	//enrich with table name mapping or table name prefix
	if config.Catalog != nil {
		var catalogBytes []byte
		switch config.Catalog.(type) {
		case string:
			catalogBytes = []byte(config.Catalog.(string))
		default:
			catalogBytes, _ = json.Marshal(config.Catalog)
		}

		catalog := &jdriverssinger.Catalog{}
		if err := json.Unmarshal(catalogBytes, catalog); err != nil {
			return err
		}

		streamNameTableNameMapping := map[string]string{}
		for _, stream := range catalog.Streams {
			streamNameTableNameMapping[stream.Stream] = enSource.SourceID + "_" + stream.Stream
			streamNameTableNameMapping[stream.TapStreamID] = enSource.SourceID + "_" + stream.TapStreamID
		}
		config.StreamTableNames = streamNameTableNameMapping
	} else {
		config.StreamTableNamesPrefix = enSource.SourceID + "_"
	}

	serializedConfig := map[string]interface{}{}
	if err := jsonutils.UnmarshalConfig(config, &serializedConfig); err != nil {
		return err
	}

	enSource.Config = serializedConfig
	return nil
}

//enrichWithAirbyteTableNamesMapping enriches with table names = source (without project + airbyte stream)
// - gets stream names from JSON
// - puts it with sourceID prefix into mapping map
func enrichWithAirbyteTableNamesMapping(enSource *jdriversbase.SourceConfig) error {
	config := &jdriversairbyte.Config{}
	if err := jsonutils.UnmarshalConfig(enSource.Config, config); err != nil {
		return err
	}

	//enrich with table name mapping or table name prefix
	if config.Catalog != nil {
		var catalogBytes []byte
		switch config.Catalog.(type) {
		case string:
			catalogBytes = []byte(config.Catalog.(string))
		default:
			catalogBytes, _ = json.Marshal(config.Catalog)
		}

		catalog := &airbyte.Catalog{}
		if err := json.Unmarshal(catalogBytes, catalog); err != nil {
			return err
		}

		streamNameTableNameMapping := map[string]string{}
		for _, stream := range catalog.Streams {
			streamNameTableNameMapping[stream.Stream.Name] = enSource.SourceID + "_" + stream.Stream.Name
		}
		config.StreamTableNames = streamNameTableNameMapping
	} else {
		config.StreamTableNamesPrefix = enSource.SourceID + "_"
	}

	serializedConfig := map[string]interface{}{}
	if err := jsonutils.UnmarshalConfig(config, &serializedConfig); err != nil {
		return err
	}

	enSource.Config = serializedConfig
	return nil
}
