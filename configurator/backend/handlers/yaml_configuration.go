package handlers

import (
	"fmt"
	"github.com/gin-gonic/gin"
	"github.com/jitsucom/jitsu/configurator/destinations"
	"github.com/jitsucom/jitsu/configurator/entities"
	"github.com/jitsucom/jitsu/configurator/random"
	"github.com/jitsucom/jitsu/configurator/storages"
	enadapters "github.com/jitsucom/jitsu/server/adapters"
	"github.com/jitsucom/jitsu/server/config"
	endriversbase "github.com/jitsucom/jitsu/server/drivers/base"
	"github.com/jitsucom/jitsu/server/middleware"
	enstorages "github.com/jitsucom/jitsu/server/storages"
	"gopkg.in/yaml.v3"
	"net/http"
)

const configHeaderText = `Generated by https://cloud.jitsu.com
Documentation: https://jitsu.com/docs

If executed out of our docker container and batch destinations are used, set up events logging
log:
  path: <path to event logs directory>
`

type GenerateConfigHandler struct {
	configurationsService *storages.ConfigurationsService
	defaultS3             *enadapters.S3Config
}

func NewGenerateConfigHandler(configurationsProvider *storages.ConfigurationsService) *GenerateConfigHandler {
	return &GenerateConfigHandler{
		configurationsService: configurationsProvider,
		defaultS3: &enadapters.S3Config{
			AccessKeyID: "Please fill this field with your S3 credentials",
			SecretKey:   "Please fill this field with your S3 credentials",
			Bucket:      "Please fill this field with your S3 bucket",
			Region:      "Please fill this field with your S3 region",
		}}
}

type Server struct {
	Name    *yaml.Node         `json:"name" yaml:"name,omitempty"`
	APIKeys []*entities.APIKey `json:"auth" yaml:"auth,omitempty"`
}

type Config struct {
	Server       Server                                 `json:"server" yaml:"server,omitempty"`
	Destinations map[string]*config.DestinationConfig   `json:"destinations" yaml:"destinations,omitempty"`
	Sources      map[string]*endriversbase.SourceConfig `json:"sources" yaml:"sources,omitempty"`
}

func (ch *GenerateConfigHandler) Handler(c *gin.Context) {
	projectID := c.Query("project_id")
	if projectID == "" {
		c.JSON(http.StatusBadRequest, middleware.ErrResponse(ErrProjectIDRequired.Error(), nil))
		return
	}
	if !hasAccessToProject(c, projectID) {
		c.JSON(http.StatusUnauthorized, middleware.ErrResponse("You are not authorized to request data for project "+projectID, nil))
		return
	}

	//** API keys (auth) **
	keys, err := ch.configurationsService.GetAPIKeysByProjectID(projectID)
	if err != nil {
		c.JSON(http.StatusBadRequest, middleware.ErrResponse(APIKeysGettingErrMsg, err))
		return
	}

	// ** Destinations **
	projectDestinations, err := ch.configurationsService.GetDestinationsByProjectID(projectID)
	if err != nil {
		c.JSON(http.StatusBadRequest, middleware.ErrResponse(DestinationsGettingErrMsg, err))
		return
	}
	postHandleDestinationIds := make([]string, 0)
	for _, d := range projectDestinations {
		if d.Type == enstorages.DbtCloudType {
			postHandleDestinationIds = append(postHandleDestinationIds, d.UID)
		}
	}
	mappedDestinations := make(map[string]*config.DestinationConfig)
	for _, destination := range projectDestinations {
		//dots can't be serialized in yaml configuration
		//destinationID := projectID + "." + destination.UID
		destinationID := destination.UID
		destinationConfig, err := destinations.MapConfig(destinationID, destination, ch.defaultS3, postHandleDestinationIds)

		if err != nil {
			c.JSON(http.StatusBadRequest, middleware.ErrResponse("Failed to build destinations response", err))
			return
		}
		mappedDestinations[destinationID] = destinationConfig
	}

	// ** Sources **
	projectSources, err := ch.configurationsService.GetSourcesByProjectID(projectID)
	if err != nil {
		c.JSON(http.StatusBadRequest, middleware.ErrResponse(SourcesGettingErrMsg, err))
		return
	}
	mappedSources := make(map[string]*endriversbase.SourceConfig)
	for _, source := range projectSources {
		//dots can't be serialized in yaml configuration
		//sourceID := projectID + "." + source.SourceID
		sourceID := source.SourceID

		var destinationIDs []string
		for _, destinationID := range source.Destinations {
			//dots can't be serialized in yaml configuration
			//destinationIDs = append(destinationIDs, projectID+"."+destinationID)
			destinationIDs = append(destinationIDs, destinationID)
		}
		mappedConfig, err := mapSourceConfig(source, destinationIDs, postHandleDestinationIds)
		if err != nil {
			c.JSON(http.StatusBadRequest, middleware.ErrResponse(fmt.Sprintf("Failed to map source [%s] config", sourceID), err))
			return
		}
		mappedSources[sourceID] = &mappedConfig
	}

	// building yaml response
	server := Server{APIKeys: keys, Name: &yaml.Node{Kind: yaml.ScalarNode, Value: random.String(5), LineComment: "rename server if another name is desired"}}
	serverConfig := Config{Server: server, Destinations: mappedDestinations, Sources: mappedSources}

	marshal, err := yaml.Marshal(&serverConfig)
	configYaml := yaml.Node{}

	if err = yaml.Unmarshal(marshal, &configYaml); err != nil {
		c.JSON(http.StatusBadRequest, middleware.ErrResponse("Failed to deserialize result configuration", err))
		return
	}
	configYaml.HeadComment = configHeaderText

	c.Header("Content-Type", "application/yaml")
	encoder := yaml.NewEncoder(c.Writer)
	defer encoder.Close()

	encoder.SetIndent(2)
	err = encoder.Encode(&configYaml)
	if err != nil {
		c.JSON(http.StatusBadRequest, middleware.ErrResponse("Failed write response", err))
	}
}
